## 指令

> 5大类：算数(add)，数据传输(load)，逻辑(or)，条件分支(beq)，无条件跳转(jump)  
不同的CPU有不同的指令集。

##### MIPS指令

格式：32位

1. R(算数和逻辑): 			操作码(6) + rs(5) + rt(5) + rd(5) + 位移量(5) + 功能码(6)
2. I(数据传输，条件分支):	操作码(6) + rs(5) + rt(5) + 地址/立即数(11)
3. J(跳转):				操作码(6) + 目标地址(26)

##### 寄存器

1. PC寄存器(指令地址寄存器)：用来存放下一条需要执行的计算机指令的内存地址
2. 指令寄存器：用来存放当前正在执行的指令
3. 条件码寄存器：用里面一个一个标记位，存放CPU进行算数或者逻辑计算的结果
4. 其他寄存器

##### CPU是如何执行指令的

通过if..else和goto实现循环
```
int main(){
	int a=0;
	for(int i=0; i<3; i++){
		a += i;
	}
}


    for (int i = 0; i < 3; i++)
   b:   c7 45 f8 00 00 00 00    mov    DWORD PTR [rbp-0x8],0x0
  12:   eb 0a                   jmp    1e <main+0x1e>
    {
        a += i;
  14:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  17:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
    for (int i = 0; i < 3; i++)
  1a:   83 45 f8 01             add    DWORD PTR [rbp-0x8],0x1
  1e:   83 7d f8 02             cmp    DWORD PTR [rbp-0x8],0x2
  22:   7e f0                   jle    14 <main+0x14>
  24:   b8 00 00 00 00          mov    eax,0x0
    }

cmp 指令， 比较结果之后，会存入条件码寄存器中。PC寄存器会自增。
jne 指令， 判断标志位，不相同(=0)就跳转, 修改PC寄存器，不自增。 jump if not equal。
jle 指令， 同理，比较对应的标志位，跳转

循环的原理就是不停的比较寄存器中的数字，不停的修改PC寄存器中的地址，使之不停的来回执行，而不是自增。直到cmp之后标记位不再修改，PC寄存器自增循环结束。
```

##### 为什么我们需要程序栈

> 函数调用的时候：
jump 指令 替换为 call 指令
函数首先会执行 push 和 mov 指令
函数结束时执行 pop 和 ret 指令
函数多重调用的时候，需要记录跳转回来的地址，而CPU里的寄存器数量不够，装不下太多的地址，为了解决这个问题，使用了栈这种数据结构（LIFO后进先出）


栈帧： 函数的参数，函数的地址等，统称为。  自顶向下压入，因为顶部的内存地址只固定的，地址是越来越小的。0xFF -> 0x00

1. 利用函数内联进行性能优化

	1. CPU指令变少，不需要跳转地址，压栈和出栈也不需要了。
	2. 但是，对于可以复用的程序指令，会展开很多次，占用的空间就变大了。

##### ELF(Execuatable and Linkable File Format 可执行与可链接文件格式)和静态链接

* 编译(Compile) - 汇编(Assemble) - 链接(Link) => 可执行文件
* 通过装载器(Loader)到内存中。 程序真正执行。

ELF：
- File Header 基本属性
- .text Section 代码段
- .data Section 数据段
- .rel.text Section 重定位表
- .symtab Section 符号表
链接器的大致流程: 链接器扫描所有的目标文件，搜集符号表里的信息，构成全局的符号表。然后根据重定位表，把所有不确定的跳转地址，根据符号表修正。最后把所有目标文件对应段进行合并，变成最终的可执行代码。


##### 程序装载

装载器需要满足的条件:
1. 可执行程序加载后占用的内存空间应该是连续的。
2. 需要同时加载很多程序，并且不能让程序自己规定在内存中加载的位置。

* 内存分段: 找出一段连续的物理内存和虚拟内存地址进行映射。
* 内存交换: 通过硬盘与内存交换，解决内存碎片的问题。
* 内存分页: 把整个物理内存空间切成一段段固定尺寸大小，对应程序同样切成一段段大小。 


##### 动态链接

> 需要链接的，不是硬盘上的目标文件代码，而是加载到内存中的共享库。
1. Windows: .dll(Dynamic-Link Libary)
2. Linux: .so(Shared Object)

* 共享代码，必须是“地址无关”
> 动态代码库内部使用相对地址。（相对于当前指令的偏移地址）


* PLT(Procedure Link Table 程序链接表)   编译时确定
* GOT(Global Offset Table 全局偏移表)    运行时计算出来

1. 从PLT中找到需要调用的函数地址
2. 从GOT中找到共享库中对应函数的虚拟内存地址











## 计算




##### 二进制编码

数字：
* 原码表示法 ： 最左侧的一位用来标记正负。 （1000 0000 都表示0，浪费了）
* 补码表示负数： 最左侧的一位在十进制计算时表示正负（1000 = -1 * 2^3 + 0 + 0 + 0 = -8）
-5 + 1
1011
0001
1100 = -8 + 4 = -4 
正负转化： 反码+1


> 10->2 

13:
13 / 2 = 6 余 1
6 / 2 = 3 余 0
3 / 2 = 1 余 1
1 / 2 = 0 余 1
= 1101(倒过来)


字符串：

ASCII码  8位二进制128个不同的数，映射到128个不同的字符里。

##### 电路

> 基本门电路，复杂电路的基础。

* 与门
* 或门
* 非门/反向器
* 或非门
* 异或门
* 与非门

AND|0|1
---|:--:|--:
0|0|0
1|0|1

OR|0|1
---|:--:|--:
0|0|1
1|1|1

NOT|0|1
---|:--:|--:
*|1|0

NOR|0|1
---|:--:|--:
0|1|0
1|0|0

XOR|0|1
---|:--:|--:
0|0|1
1|1|0

NAND|0|1
---|:--:|--:
0|1|1
1|1|0




##### 加法

半加器（加法计算）： 异或门计算个位， 或门计算进位。  

A -->  C0(进位)

B -->  S（个位）

全加器：两个半加器 + 一个或门
8位加法器由8个全加器串联而成


##### 乘法

二进制的乘法，实际上就是 移位和加法组成的
被乘数 左移， 乘数 右移
顺序相加，几位乘法就要相加几次，影响性能。

门延迟(Gate Delay): 每一个全加器，都要等待上一个全加器，才能选出下一次的结果。每经过一个门电路，就是一层延迟(T),一个全加器 3T 延迟
时钟频率：

优化：电路天然的并行性， 只需要3T即可计算出第N位是否进位。



##### 浮点数
> 浮点数其实是一个不能确定大小的数据范围，并不是精确的数值，只是一个近似值。

* 定点数表示：BCD编码 比如32位， 999999.99   0..(24)..0 0..(8)..0 
缺点：32位可以表示40亿个不同的数，但是BCD编码下，智能表示1亿个数。没有办法比同时表示很大或很小的数。

* 浮点数表示：(-1)^s * 1.f * 2^e

s = 符号位 | e = 指数位 | 有效数位
--|:--:|--:
1比特|8比特|23比特

e|f|s|浮点数
--|:--:|:--:|--:
0|0|0or1|0
0|!=0|0or1|0.f
255|0|0|无穷大
255|0|1|无穷小
255|!=0|0or1|NAN

* 浮点数的二进制转化

9.1
整数部分：
9 / 2 = 4   1
4 / 2 = 2   0
2 / 2 = 1   0
1 / 2 = 0   1

9 = 1001


小数部分：

二进制转成十进制：
0.1001
1 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4 = 0.5625

十进制转成二进制：
0.1

0.1 * 2 = 0.2   0 （是否超过1）
0.2 * 2 = 0.4   0
0.4 * 2 = 0.8   0
0.8 * 2 = 1.6   1  (超过1 减去 1)
0.6 * 2 = 1.2   1
0.2 * 2 = 0.4   0

9.1 = 1001.000110....

用科学记数法： 1.001000110.... * 2 ^3
(-1)^s * 1.f * 2^e

s = 0
f = 00100011001100110011 001  (23位)
e = 00000011


***浮点数的加法和精度损失***
先对齐，再计算。
0.5 + 0.125

s = 0       0
f = 1.000...     1.000...
e = 1        3
对齐
f = 1.000...     0.01
e = 1        1


f = 1.01

因为会进行右移，导致丢失精度。32位浮点数的有效长度一共是23位，如果两数字相差2^24，想加之后结果就完全不会变化。

> 浮点数的加法存在着精度损失，特别是大量加法运算中累积产生的巨大精度损失。在日常中需要用到精确的数字相加时，一般使用定点数或整数，浮点数使用用在不需要那么精确的计算中，比如距离等...


------------
